<!-- build time:Sun May 05 2019 18:42:23 GMT+0800 (CST) --><!DOCTYPE html><html lang="zh-Hans" class="loading"><head><meta name="generator" content="Hexo 3.8.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"><meta name="viewport" content="width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><title>Unity Shader 关于tex2D中 dx dy 的猜想 - 鸵鸟工作室</title><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black-translucent"><meta name="google" content="notranslate"><meta name="keywords" content="Fechin,"><meta name="description" content="鸵鸟工作室,问题在 Unity Shader-地形纹理合并文章里面有提到一个黑线问题. 其实在OpenGL ES3.0以后直接用Texture2DArray就可以避免了. 不过我又犯贱研究了一下为何在Atlas,"><meta name="author" content="鸵鸟工作室"><link rel="alternative" href="atom.xml" title="鸵鸟工作室" type="application/atom+xml"><link rel="icon" href="/img/favicon.png"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css"><link rel="stylesheet" href="/css/diaspora.css"><script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script>(adsbygoogle=window.adsbygoogle||[]).push({google_ad_client:"ca-pub-8691406134231910",enable_page_level_ads:!0})</script><script async custom-element="amp-auto-ads" src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js"></script></head></html><body class="loading"><span id="config-title" style="display:none">鸵鸟工作室</span><div id="loader"></div><div id="single"><div id="top" style="display:block"><div class="bar" style="width:0"></div><a class="icon-home image-icon" href="javascript:;" data-url="http://鸵鸟工作室.fun"></a><div title="播放/暂停" class="icon-play"></div><h3 class="subtitle">Unity Shader 关于tex2D中 dx dy 的猜想</h3><div class="social"><div><div class="share"><a title="获取二维码" class="icon-scan" href="javascript:;"></a></div><div id="qr"></div></div></div><div class="scrollbar"></div></div><div class="section"><div class="article"><div class="main"><h1 class="title">Unity Shader 关于tex2D中 dx dy 的猜想</h1><div class="stuff"><span>十一月 04, 2018</span><ul class="post-tags-list"><li class="post-tags-list-item"><a class="post-tags-list-link" href="/tags/Shader/">Shader</a></li><li class="post-tags-list-item"><a class="post-tags-list-link" href="/tags/Terrain/">Terrain</a></li><li class="post-tags-list-item"><a class="post-tags-list-link" href="/tags/Texture/">Texture</a></li></ul></div><div class="content markdown"><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p><img src="/media/15413190897325.png" alt=""></p><p>在 <a href="http://candycat1992.github.io/2016/11/28/blend-terrain-textures/" target="_blank" rel="noopener">Unity Shader-地形纹理合并</a>文章里面有提到一个黑线问题. 其实在OpenGL ES3.0以后直接用<code>Texture2DArray</code>就可以避免了. 不过我又犯贱研究了一下为何在Atlas里面会有这个问题和解决方案.</p><p>里面内容涉及还是挺多的,资料查了很多 但是没有找到很官方的解释. 所以我只能说一下我的<code>猜想</code>具体是否正确 目前以我所知的知识还无法考证☹️</p><h2 id="为何有黑线"><a href="#为何有黑线" class="headerlink" title="为何有黑线"></a>为何有黑线</h2><p>这个问题还不好一下说清楚,所以要分几步来说明一下</p><h3 id="UV采样"><a href="#UV采样" class="headerlink" title="UV采样"></a>UV采样</h3><p><img src="/media/15413017429494.jpg" alt=""></p><p>在纹理的设置中分别对应了三种采样方式:</p><ul><li><code>Point</code>点采样-无滤波</li><li><code>Billnear</code>双线性插值</li><li><code>Trillinear</code>三线性插值.</li></ul><p>那这些到底是什么意思呢?</p><p>在 <a href="https://item.jd.com/11047263.html" target="_blank" rel="noopener">3D游戏编程大师技巧 下册 P560 9.6基本采样理论</a>中专门说明了这个问题.</p><p>我这里就简单说下我的理解, 重复说一遍没啥意义.大神已经给解释的很清楚.</p><h4 id="Point"><a href="#Point" class="headerlink" title="Point"></a>Point</h4><p>点采样方式,文章中首先举出的例子就是 一维纹理的采样.</p><p><img src="/media/15413028045249.jpg" alt=""></p><p>比如有一个一维纹理.分别要采样到一个1x4的mesh上和一个1x14的mesh上</p><p>两者的采样率分辨为 8/4 =2 和 8/14 = 0.57 . 根据采样率映射到的 1x14上的采样点如下图. 再向下取整. 从而得到最终的像素点.</p><p><img src="/media/15413030168525.jpg" alt=""></p><h4 id="Billnear-双线性插值"><a href="#Billnear-双线性插值" class="headerlink" title="Billnear 双线性插值"></a>Billnear 双线性插值</h4><p>比如上面的例子 对于样本12 <code>7.41</code> 直接使用7号位置的像素值 显然不准确. 所以不如</p><p><code>最终采样结果 = 7号样本的59%(1-0.41) + 8号样本的41%</code></p><p>这样采样来的准确.</p><p>同理将此逻辑推广到二维坐标系下就可以同时根据4个像素点进行采样渲染. 逻辑如图:</p><p><img src="/media/15413032003880.jpg" alt=""></p><p>补充:</p><p><a href="http://alt.3dcenter.org/artikel/grafikfilter/index4.php" target="_blank" rel="noopener">Link</a></p><p><img src="/media/15414029440353.jpg" alt=""><br><img src="/media/15414029790166.jpg" alt=""><br><img src="/media/15414029563687.jpg" alt=""></p><h4 id="Trillinear-三线性插值"><a href="#Trillinear-三线性插值" class="headerlink" title="Trillinear 三线性插值"></a>Trillinear 三线性插值</h4><p>这里涉及到的原理有些深奥了. 我自己也没太弄明白. 具体的可以参考</p><ul><li><a href="https://item.jd.com/11047263.html" target="_blank" rel="noopener">3D游戏编程大师技巧 下册 P724 12.7 Mipmapping和三线性纹理滤波</a></li><li><a href="https://blog.csdn.net/libing_zeng/article/details/74095212" target="_blank" rel="noopener">图形学中的贴图采样、走样与反走样等，图形学走样图形学中的贴图采样、走样与反走样等，图形学走样</a></li></ul><p>说下我目前<code>有可能</code>理解到的部分:</p><ul><li>走样问题是肯定会出现的,使用Mipmapping进行滤波可以延缓其出现的时间</li><li>三线性插值是在 双线性插值插值的基础上 同时参考了多张Mipmapping</li></ul><p>纹理走样如图(未开Mip):</p><p><img src="/media/15413035593478.jpg" alt=""></p><h3 id="再谈黑线问题"><a href="#再谈黑线问题" class="headerlink" title="再谈黑线问题"></a>再谈黑线问题</h3><p>知道了UV如何采样,再回过头来很黑线问题. 黑线问题应该是因为在边界处采样时候 GPU “用错了” Mipmapping导致的.</p><p>那这又引出另外一个问题,GPU如何知道该用哪张Mipmapping去采样呢?</p><h4 id="ddx-ddy"><a href="#ddx-ddy" class="headerlink" title="ddx ddy"></a>ddx ddy</h4><p>恩,引出本文主题之前 还有一个概念需要交代一下就是. 现在显卡进行采样时候 都会同时取出相邻的四个fragment. 看到的资料是说 因为这么做很容易.</p><p>所以在fragment shader中我们可以通过 ddx(a),ddy(a) 取得周围临近fragment和当前fragment的差值.</p><p>注意一点对 ddx,ddy的理解就是.</p><blockquote><p>这个是在取周围fragment的数据,至于这个数据是uv还是normal还是pos那是你自己需要关心的. 这个函数不会做处理.</p></blockquote><p>因为取得的这个相差值所在的两个点距离很小,所以我们也近似的认为ddx(a),ddy(a)取得是a数据在当前fragment的导数(或者是叫偏导数?)</p><h5 id="ddx-ddy的用处"><a href="#ddx-ddy的用处" class="headerlink" title="ddx ddy的用处"></a>ddx ddy的用处</h5><p>那这东西取出来有什么用呢?</p><ul><li>确定采样时候使用哪个 Mipmapping</li><li>在fragment中求的法线</li><li>图片锐化</li></ul><p>求Mipmapping后面再讲,先说取法线问题.</p><p>查考<a href="http://www.aclockworkberry.com/shader-derivative-functions/#footnote_3_1104" target="_blank" rel="noopener">An introduction to shader derivative functions</a>这篇文章即可. 注意看他的那个3D模型</p><p><img src="/media/15413144386599.jpg" alt=""></p><p><img src="/media/15413144187807.jpg" alt=""></p><p>图片锐化问题 可以看:</p><p><a href="http://www.cnblogs.com/tekkaman/p/9542449.html" target="_blank" rel="noopener">HLSL ddx / ddy</a></p><h4 id="tex2D-dx-dy"><a href="#tex2D-dx-dy" class="headerlink" title="tex2D dx dy"></a>tex2D dx dy</h4><p>再返回头来看黑线问题, <a href="http://candycat1992.github.io/2016/11/28/blend-terrain-textures/" target="_blank" rel="noopener">Unity Shader-地形纹理合并</a>文章中是使用的</p><p>四参数tex2D函数进行的采样</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">float4 col0 = tex2D(<span class="name">_BlockMainTex</span>, uv0, dx, dy)<span class="comment">;</span></span><br><span class="line">float4 col1 = tex2D(<span class="name">_BlockMainTex</span>, uv1, dx, dy)<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>双参数的函数根据<a href="https://blog.csdn.net/u013467442/article/details/46444673" target="_blank" rel="noopener">MipMap的LOD实现原理</a>中所提到的是可以拆解为</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">tex2D(sampler2D <span class="built_in">tex</span>, float4 uv)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">float</span> lod = CalcLod(ddx(uv), ddy(uv));</span><br><span class="line">    uv.w= lod;</span><br><span class="line">    <span class="built_in">return</span> tex2Dlod(<span class="built_in">tex</span>, uv);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以四参数的据我猜想应该可以理解为</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">tex2D(sampler2D tex, float4 uv, float2 <span class="built_in">dx</span>, float2 <span class="built_in">dy</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="meta">float</span> lod = CalcLod(<span class="built_in">dx</span>, <span class="built_in">dy</span>)<span class="comment">;</span></span><br><span class="line">    uv.w= lod<span class="comment">;</span></span><br><span class="line">    return tex2Dlod(tex, uv)<span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也就是指定好dx,dy 无需再用 ddx 和 ddy 去计算了.</p><h4 id="Atlas-Texture导致的偏导错误"><a href="#Atlas-Texture导致的偏导错误" class="headerlink" title="Atlas Texture导致的偏导错误"></a>Atlas Texture导致的偏导错误</h4><p>说完上面这一坨理论知识,终于可以说文章的重点了.🙃</p><p>那在Atlas Texture中的黑线是怎么来的呢</p><p>引用<a href="http://candycat1992.github.io/2016/11/28/blend-terrain-textures/" target="_blank" rel="noopener">Unity Shader-地形纹理合并</a>文章中的话</p><blockquote><p>如果直接使用上面的uv0和uv1对纹理采样，那么在地形接缝处会出现明显的问题：<br>这主要是因为这里的纹理tiling是我们手动对worldScale取frac得到的，这样纹理采样坐标的偏导其实是不连续的，而通常我们使用单张纹理的tiling是连续的，是由图形API和硬件帮我们处理平铺类型的。</p></blockquote><p>同时参考文章 <a href="https://gamedev.stackexchange.com/questions/130888/what-are-screen-space-derivatives-and-when-would-i-use-them" target="_blank" rel="noopener">What are screen space derivatives and when would I use them</a></p><p><img src="/media/15413163235910.png" alt=""></p><p>在单张纹理时候,将Wrap Mode选为 <code>Repeat</code> . 遇到uv超过1时候<br><img src="/media/15413163807475.jpg" alt=""></p><p>比如横向排列的一组uv坐标为</p><blockquote><p>(0,0.3),(0,0.7),(0,0.9),(0,1.1),(0,1.5)</p></blockquote><p>GPU是知道如何处理uv采样的,因为是<code>Repeat</code>模式,所以会采样到当前纹理左侧部分的像素.</p><p>但是在Atlas Texture中 Wrap Mode只能选择<code>Clamp</code>. 并且对于(0,1.1)会首先frac掉整数,把当前点的uv变为0.1</p><p>假设</p><blockquote><p>A (0,0.7) B (0,0.9) C (0,1.1)</p></blockquote><p>是三个连续的片元. 那</p><p>A-B = 0.7 - 0.9 = -0.2<br>B-C = 0.9 - 0.1 = 0.8</p><p>B-C此处的变化率应该仍旧是 -0.2. 而-0.2 我们假设对应的是最高等级的纹理. 但是0.8 就可能对应的是经过Mipmapping压缩过的纹理了.所以在这个点上的片元就出现了</p><p>使用错Mipmapping的问题 应该使用大纹理时候使用了小纹理.</p><p>而小纹理由于尺寸缩小,所以边界采样时候就发生了越界. 也就是看到的<code>黑线</code></p><h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><p>使用一张1024的纹理,中间32x32大小区域为绿色,其余区域均为黑色. 纹理的Wrap Mode选为Clamp. 相机贴近地表 看向远处.</p><p><img src="/media/15413186056722.jpg" alt=""></p><p>构建一个100x100的Quad平铺,Quad纹理取值范围为:</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> uvMin = (<span class="number">512</span> - pixelValue) / <span class="number">1024</span>f;</span><br><span class="line"><span class="keyword">var</span> uvMax = (<span class="number">512</span> + pixelValue) / <span class="number">1024</span>f;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> xIndex = <span class="number">0</span>; xIndex &lt; xNum; xIndex++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> yIndex = <span class="number">0</span>; yIndex &lt; yNum; yIndex++)</span><br><span class="line">    &#123;</span><br><span class="line">        ...</span><br><span class="line">        uv[startIndex] = <span class="keyword">new</span> <span class="type">Vector2</span>(uvMin, uvMin);</span><br><span class="line">        uv[startIndex + <span class="number">1</span>] = <span class="keyword">new</span> <span class="type">Vector2</span>(uvMax, uvMin);</span><br><span class="line">        uv[startIndex + <span class="number">2</span>] = <span class="keyword">new</span> <span class="type">Vector2</span>(uvMin, uvMax);</span><br><span class="line">        uv[startIndex + <span class="number">3</span>] = <span class="keyword">new</span> <span class="type">Vector2</span>(uvMax, uvMax);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>GUI中拖动滑块调整pixelValue的取值范围</p><p>Mid Off:</p><p><img src="https://media.giphy.com/media/OjHiOHUcK0HE7Fgfnk/giphy.gif" alt="Mid Off"></p><p><img src="/media/15413189175347.jpg" alt=""></p><p>Mid On:</p><p><img src="/media/15413188940570.jpg" alt=""></p><p><img src="https://media.giphy.com/media/1j8P01TgcQbEa4LLnb/giphy.gif" alt="Mid On"></p><p>可以看出 在打开了<code>Mipmapping</code>后,地表过早的出现了黑线,并且随着地图渐远黑线越发的明显</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p><a href="http://candycat1992.github.io/2016/11/28/blend-terrain-textures/" target="_blank" rel="noopener">Unity Shader-地形纹理合并</a> 文中给出的解决方案是分两步</p><p>首先是每个纹理周围留出1个素文(texel)的拉伸,然后把dx,dy clamp到+- 0.0078125 也就是其文章中使用的1个素文范围内.</p><p>我不是很理解这么做的目的,因为这样确实可以”解决”裂缝的问题,但是解决的思路其实和 直接关闭 Mipmapping 没有任何区别. 因为Clamp到一个素文宽度 会导致<code>CalcLod</code>时候总选择最大的那张纹理.</p><p>我自己也尝试写了一下那个Shader,不过因为我是单张纹理Clmap的,不需要那么复杂的计算uv所以直接</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">fixed4 frag(v2f i) : SV_Target </span><br><span class="line">&#123;</span><br><span class="line">  //<span class="number">0</span>.<span class="number">0009765625</span></span><br><span class="line">  float2 dx = clamp(ddx(i.uv), -<span class="number">0</span>.<span class="number">0009765625</span>, <span class="number">0</span>.<span class="number">0009765625</span>)<span class="comment">;</span></span><br><span class="line">  float2 dy = clamp(ddy(i.uv), -<span class="number">0</span>.<span class="number">0009765625</span>, <span class="number">0</span>.<span class="number">0009765625</span>)<span class="comment">;</span></span><br><span class="line">  fixed4 c = tex2D(_MainTex,i.uv,dx,dy)<span class="comment">;</span></span><br><span class="line">  </span><br><span class="line">  return fixed4(c.rgb, <span class="number">1</span>.<span class="number">0</span>)<span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>得到的结果和我关闭Mipmapping以后的结果一样.</p><h2 id="疑惑"><a href="#疑惑" class="headerlink" title="疑惑"></a>疑惑</h2><p>因为我Terrain准备直接使用<code>Texture2DArray</code>去做,所以也就不打算再深入研究下去了. 有几个地方还是没有弄清楚</p><p>ddx(a),ddy(a) 查到的资料部分显示 其实现的方式是直接从临近的fragment中取得值,也就是不是通过计算得到的偏导数.</p><p>我尝试了一下直接写ddx(1.23f),按说这样写应该是直接报错的. 但是我是可以编译过去.转换后的代码类似于:</p><blockquote><p>vec4(vec4(1.23, 1.23, 0.0, 0.0)).xy</p></blockquote><p>但确实是实现时候没有调用dFdy(a),dFdx(a). (如果ddx(uv)等变量时候 是会转化为dFdy和dFdx的)</p><p>所以不知道ddx ddy 是否真的是从周围fragment中”取” 数据, 而不是在计算.</p><p>另外一个没有搞懂的就是<a href="http://candycat1992.github.io/2016/11/28/blend-terrain-textures/" target="_blank" rel="noopener">Unity Shader-地形纹理合并</a>文章中clamp一下dx,dy的和直接关闭Mipmapping的区别.</p><hr><h2 id="补充说明"><a href="#补充说明" class="headerlink" title="补充说明"></a>补充说明</h2><p>后来又研究了一下Mip问题 有一些收获</p><h3 id="MIP-Banding问题"><a href="#MIP-Banding问题" class="headerlink" title="MIP Banding问题"></a>MIP Banding问题</h3><p>关于 Billnear 和 Trillinear 还涉及到一个 MIP Banding问题. 相关资料:</p><p><a href="http://alt.3dcenter.org/artikel/2003/10-26_a_english.php" target="_blank" rel="noopener">Will “brilinear” filtering persist?</a><br><a href="https://www.ht4u.net/reviews/2010/amd_radeon_hd_6800_reloaded/index10.php" target="_blank" rel="noopener">amd_radeon_hd_6800_reloaded</a></p><p>MIP Banding现象:</p><p><img src="/media/15414003031935.jpg" alt=""></p><p><img src="/media/15414003462645.jpg" alt=""></p><p>去除后效果:</p><p><img src="/media/15414004289629.jpg" alt=""></p><p>解释理解了大概,应该和之前猜想的一样. 因为双线性插值没有在多个Mip之间混,所以当出现Mip切换时候 会有明显”条带”现象. 但是三线性插值因为参考了多找Mip.所以不会出现这种现象.</p><p>同时<a href="http://alt.3dcenter.org/artikel/2003/10-26_a_english.php" target="_blank" rel="noopener">Will “brilinear” filtering persist?</a>这篇文章也提到了 走样的原因. 和之前理解的也应该一样</p><blockquote><p>If the next larger MIP texture is applied, texture shimmering (so called aliasing) would appear, since the texture would be scanned already too coarse meshed with four samples per color value. Here the first disadvantage occurs, if you filter from only one MIP map: The “Level of Detail” has to be determined in such a way, that in any case aliasing is avoided, cause no one would (of course) accept texture shimmering. Distributed over the polygon, the pixels get more or less texture details depending upon that.</p></blockquote><h3 id="Brilinear-伪三线性插值"><a href="#Brilinear-伪三线性插值" class="headerlink" title="Brilinear 伪三线性插值"></a>Brilinear 伪三线性插值</h3><p>之前<code>Brilinear</code>将这个词理解为双线性插值应该是不准确的. 目前Unity中的<code>Brilinear</code>应该已经是伪三线性插值了.</p><p>经典双线性插值</p><p><img src="/media/15414023037387.jpg" alt=""></p><p>三线性插值<br><img src="/media/15414023082004.jpg" alt=""></p><p>Brilinear伪三线性插值<br><img src="/media/15414023130330.jpg" alt=""></p><p><a href="http://alt.3dcenter.org/artikel/2003/10-26_a_english.php" target="_blank" rel="noopener">Will “brilinear” filtering persist?</a></p><blockquote><p>“Brilinear” filtering likewise interpolates textures to suppress MIP banding. The tri-band is significantly reduced though. Within broad ranges solely bilinear filtering is used. Please keep in mind that “brilinear” is just an artificial word without any official use. “Pseudo-trilinear” sounds more technical in the first instance but it describes the filter just as insufficient. The effect shall be illustrated with images by imitating colored MIP maps with a paint application.</p></blockquote><p><a href="https://www.opengl.org/discussion_boards/showthread.php/171485-Texture-LOD-calculation-%28useful-for-atlasing%29" target="_blank" rel="noopener">Link</a></p><blockquote><ul><li><p>Have you tried the brilinear cheat?</p></li><li><p>I am not familiar with this. Can you explain?</p></li><li><p>You’re not doing your own texture filtering in the shader, so it’s not really applicable. But this is an ancient NVidia trick to save bandwidth when doing trilinear interpolation. Basically, instead of always sampling 2 MIPs and blending between them, you only sample 2 MIPs for like the middle 33% between two MIPmaps and do a fast blend into and out of that region. When you’re less than 33% away from a MIPmap, you just clamp to the result that MIPmap gives you and don’t even sample the other MIP. Results in lower texture filtering quality (blurring/aliasing), but saves bandwidth.</p></li></ul></blockquote><!--[if lt IE 9]><script>document.createElement('audio');</script><![endif]--><audio id="audio" loop preload="auto" controls data-autoplay="false"><source type="audio/mpeg" src=""></audio><ul id="audio-list" style="display:none"><li title="0" data-url="http://link.hhtjim.com/163/5146554.mp3"></li><li title="1" data-url="http://link.hhtjim.com/qq/001faIUs4M2zna.mp3"></li></ul></div><div id="gitalk-container" class="comment link" data-ae="false" data-ci="" data-cs="" data-r="" data-o="" data-a="" data-d="false">查看评论</div></div></div></div></div></body><script src="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script><script src="//lib.baomitu.com/jquery/1.8.3/jquery.min.js"></script><script src="/js/plugin.js"></script><script src="/js/diaspora.js"></script><link rel="stylesheet" href="/photoswipe/photoswipe.css"><link rel="stylesheet" href="/photoswipe/default-skin/default-skin.css"><script src="/photoswipe/photoswipe.min.js"></script><script src="/photoswipe/photoswipe-ui-default.min.js"></script><div class="pswp" tabindex="-1" role="dialog" aria-hidden="true"><div class="pswp__bg"></div><div class="pswp__scroll-wrap"><div class="pswp__container"><div class="pswp__item"></div><div class="pswp__item"></div><div class="pswp__item"></div></div><div class="pswp__ui pswp__ui--hidden"><div class="pswp__top-bar"><div class="pswp__counter"></div><button class="pswp__button pswp__button--close" title="Close (Esc)"></button> <button class="pswp__button pswp__button--share" title="Share"></button> <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button> <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button><div class="pswp__preloader"><div class="pswp__preloader__icn"><div class="pswp__preloader__cut"><div class="pswp__preloader__donut"></div></div></div></div></div><div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap"><div class="pswp__share-tooltip"></div></div><button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)"></button> <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)"></button><div class="pswp__caption"><div class="pswp__caption__center"></div></div></div></div></div><!-- rebuild by neat -->