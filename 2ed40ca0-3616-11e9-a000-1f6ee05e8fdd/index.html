<!-- build time:Sun May 05 2019 18:42:23 GMT+0800 (CST) --><!DOCTYPE html><html lang="zh-Hans" class="loading"><head><meta name="generator" content="Hexo 3.8.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"><meta name="viewport" content="width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><title>Unity战争迷雾(Fog Of War) - 鸵鸟工作室</title><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black-translucent"><meta name="google" content="notranslate"><meta name="keywords" content="Fechin,"><meta name="description" content="鸵鸟工作室,项目地址笔记战争迷雾在2D项目中有许多取巧的实现方式,但是在3D项目中没找到什么比较巧妙的方式.传统的实现方式就是用一张纹理两个通道 一个表示已经探索的区域,另外一个通道表示当前视野可见的区域.但是,"><meta name="author" content="鸵鸟工作室"><link rel="alternative" href="atom.xml" title="鸵鸟工作室" type="application/atom+xml"><link rel="icon" href="/img/favicon.png"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css"><link rel="stylesheet" href="/css/diaspora.css"><script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script>(adsbygoogle=window.adsbygoogle||[]).push({google_ad_client:"ca-pub-8691406134231910",enable_page_level_ads:!0})</script><script async custom-element="amp-auto-ads" src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js"></script></head></html><body class="loading"><span id="config-title" style="display:none">鸵鸟工作室</span><div id="loader"></div><div id="single"><div id="top" style="display:block"><div class="bar" style="width:0"></div><a class="icon-home image-icon" href="javascript:;" data-url="http://鸵鸟工作室.fun"></a><div title="播放/暂停" class="icon-play"></div><h3 class="subtitle">Unity战争迷雾(Fog Of War)</h3><div class="social"><div><div class="share"><a title="获取二维码" class="icon-scan" href="javascript:;"></a></div><div id="qr"></div></div></div><div class="scrollbar"></div></div><div class="section"><div class="article"><div class="main"><h1 class="title">Unity战争迷雾(Fog Of War)</h1><div class="stuff"><span>二月 22, 2019</span><ul class="post-tags-list"><li class="post-tags-list-item"><a class="post-tags-list-link" href="/tags/Shader/">Shader</a></li></ul></div><div class="content markdown"><p><img src="http://tunied.github.io/Gifs/FogOfWar.gif" alt=""></p><p><a href="https://github.com/Tunied/Fog-Of-War" target="_blank" rel="noopener">项目地址</a></p><h2 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h2><p>战争迷雾在2D项目中有许多取巧的实现方式,但是在3D项目中没找到什么比较巧妙的方式.</p><p>传统的实现方式就是用一张纹理两个通道 一个表示已经探索的区域,另外一个通道表示当前视野可见的区域.</p><p>但是使用这张纹理进行迷雾绘制的方式各有各的方式,我参考到的有三种</p><ul><li><a href="https://github.com/AsehesL/FogOfWar" target="_blank" rel="noopener">AsehesL</a></li><li><a href="https://github.com/smilehao/fog-of-war" target="_blank" rel="noopener">smilehao</a></li><li><a href="https://assetstore.unity.com/packages/tools/utilities/ultimate-fog-of-war-76011" target="_blank" rel="noopener">Ultimate Fog of War</a></li></ul><p>三种方式在制作迷雾纹理上都大同小异,主要差别是在纹理的运用上</p><h3 id="后期屏幕特效"><a href="#后期屏幕特效" class="headerlink" title="后期屏幕特效"></a>后期屏幕特效</h3><p>AsehesL使用的方式是采用的后期处理</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">OnRenderImage</span><span class="params">(RenderTexture src, RenderTexture dst)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!m_IsInitialized)</span><br><span class="line">        Graphics.Blit(src, dst);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        m_Renderer.RenderFogOfWar(m_Camera, m_Map.GetFOWTexture(), src, dst);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://mp.weixin.qq.com/s/riKooDt7PyzTpJAxOqoVwg" target="_blank" rel="noopener">UWA 战争迷雾开源库测评</a> 之前专门做过一期评测.</p><p><img src="/media/15508288430622.jpg" alt=""></p><p>对于两三年前的千元机来说 性能有些堪忧.</p><h3 id="单Plane渲染"><a href="#单Plane渲染" class="headerlink" title="单Plane渲染"></a>单Plane渲染</h3><p>smilehao 采用的就是比较讨巧的办法,直接渲染到一个Plane上面.然后设置其RenderQueue为最后渲染.</p><p><img src="/media/15508290419587.jpg" alt=""></p><p>Shader:<br></p><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Tags&#123; <span class="string">"Queue"</span> = <span class="string">"Transparent+151"</span> <span class="string">"IgnoreProjector"</span> = <span class="string">"True"</span> <span class="string">"RenderType"</span> = <span class="string">"Transparent"</span> &#125;</span><br></pre></td></tr></table></figure><p></p><p>这种渲染方式 对于不可以自主调整 相机位置+高度 的游戏来说 是一种不错的渲染方式. 性能应该很省. 但是在能调整视角高低的情况下会穿帮</p><p>正常情况:</p><p><img src="/media/15508292599284.jpg" alt=""></p><p>穿帮情况:<br><img src="/media/15508293159172.jpg" alt=""><br><img src="/media/15508293574697.jpg" alt=""></p><p>尤其是将相机压低以后效果会更明显.</p><h3 id="Custom-Shader"><a href="#Custom-Shader" class="headerlink" title="Custom Shader"></a>Custom Shader</h3><p>Ultimate Fog of War 实现的方式就比较传统了, 就是直接对Fow纹理进行采样了. 然后把所有的Shader重新实现一遍</p><p><img src="/media/15508295325042.jpg" alt=""></p><h2 id="我的选择"><a href="#我的选择" class="headerlink" title="我的选择"></a>我的选择</h2><p><img src="/media/15508296698919.jpg" alt=""><br>首先我要制作的游戏是 一款RTS塔防 相机效果类似于 War3. 可全局移动+俯仰角调整.</p><p>考虑到性能问题,对于<code>AsehesL</code>的后期渲染方式 应该会吃不消. 而<code>smilehao</code>的方式 当相机调整俯仰角度时候会出现穿帮. 所以我是直接采用的<br><code>Ultimate Fog of War</code>的方式.</p><p>本来是想直接用这个插件的,不过没有太研究透这个插件 一直不知道怎么把周围迷雾调为全黑. 另外这个插件对于我这个项目来说有点太冗余了. 就自己写了一个.</p><h3 id="Custom-Shader-1"><a href="#Custom-Shader-1" class="headerlink" title="Custom Shader"></a>Custom Shader</h3><p>使用CustomShader的好处还有一个就是首先sampling Fow纹理 判断当前不可见 (fow.r &gt; 0.9) 后续就可以直接return fixed4(0,0,0,1). 不必再继续后面的sampling+光照计算了.</p><p>对于渲染很重的项目且屏幕内大面积出现迷雾效果时候. 用这种CutstomShader来做应该会更省一些(未测试.)</p><p>不过我这个项目 大部分时候屏幕内出现迷雾的区域都不大 Shader里面用if反而是增加消耗的.所以我没加判断. 并且加入判断后在编辑器里面所有模型都是纯黑的.编辑起来也很麻烦.</p><h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><p>参考的三个项目都使用了线程池.我也尝试的用了一下 不过没太弄懂 就放弃了.</p><p>Unity的线程池我了解到的是只能操作非Unity的API,也就是只能用于填充 FillTexture时候使用的 ColorBuffer[]</p><p>但是我的项目大量迷雾探索对象为静态的,只有一个英雄可以自由移动. 而对于静态的探索对象 我是直接Cache到一个temp array里面了</p><p>每次计算ColorBuffer时候 直接ArrayCopy的. 然后每个移动的角色自己维护一个可见范围List&lt;&gt;</p><p>也就是每次FillTexture时候 就是一次ArrayCopy + 少量的List ForEach.</p><p>并且我的Fow纹理不会经常变动,所以最后没有纠结使用线程的问题.</p><!--[if lt IE 9]><script>document.createElement('audio');</script><![endif]--><audio id="audio" loop preload="auto" controls data-autoplay="false"><source type="audio/mpeg" src=""></audio><ul id="audio-list" style="display:none"><li title="0" data-url="http://link.hhtjim.com/163/5146554.mp3"></li><li title="1" data-url="http://link.hhtjim.com/qq/001faIUs4M2zna.mp3"></li></ul></div><div id="gitalk-container" class="comment link" data-ae="false" data-ci="" data-cs="" data-r="" data-o="" data-a="" data-d="false">查看评论</div></div></div></div></div></body><script src="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script><script src="//lib.baomitu.com/jquery/1.8.3/jquery.min.js"></script><script src="/js/plugin.js"></script><script src="/js/diaspora.js"></script><link rel="stylesheet" href="/photoswipe/photoswipe.css"><link rel="stylesheet" href="/photoswipe/default-skin/default-skin.css"><script src="/photoswipe/photoswipe.min.js"></script><script src="/photoswipe/photoswipe-ui-default.min.js"></script><div class="pswp" tabindex="-1" role="dialog" aria-hidden="true"><div class="pswp__bg"></div><div class="pswp__scroll-wrap"><div class="pswp__container"><div class="pswp__item"></div><div class="pswp__item"></div><div class="pswp__item"></div></div><div class="pswp__ui pswp__ui--hidden"><div class="pswp__top-bar"><div class="pswp__counter"></div><button class="pswp__button pswp__button--close" title="Close (Esc)"></button> <button class="pswp__button pswp__button--share" title="Share"></button> <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button> <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button><div class="pswp__preloader"><div class="pswp__preloader__icn"><div class="pswp__preloader__cut"><div class="pswp__preloader__donut"></div></div></div></div></div><div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap"><div class="pswp__share-tooltip"></div></div><button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)"></button> <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)"></button><div class="pswp__caption"><div class="pswp__caption__center"></div></div></div></div></div><!-- rebuild by neat -->