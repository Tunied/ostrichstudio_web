<!-- build time:Sun May 05 2019 18:42:23 GMT+0800 (CST) --><!DOCTYPE html><html lang="zh-Hans" class="loading"><head><meta name="generator" content="Hexo 3.8.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"><meta name="viewport" content="width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><title>Shader Cheat Sheet - 鸵鸟工作室</title><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black-translucent"><meta name="google" content="notranslate"><meta name="keywords" content="Fechin,"><meta name="description" content="鸵鸟工作室,CG 函数速查手册LinkUNITY_MATRIX_MVP使用方法:12mul(UNITY_MATRIX_MVP,*) //旧版UnityObjectToClipPos(*) //新版作用:将模型空,"><meta name="author" content="鸵鸟工作室"><link rel="alternative" href="atom.xml" title="鸵鸟工作室" type="application/atom+xml"><link rel="icon" href="/img/favicon.png"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css"><link rel="stylesheet" href="/css/diaspora.css"><script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script>(adsbygoogle=window.adsbygoogle||[]).push({google_ad_client:"ca-pub-8691406134231910",enable_page_level_ads:!0})</script><script async custom-element="amp-auto-ads" src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js"></script></head></html><body class="loading"><span id="config-title" style="display:none">鸵鸟工作室</span><div id="loader"></div><div id="single"><div id="top" style="display:block"><div class="bar" style="width:0"></div><a class="icon-home image-icon" href="javascript:;" data-url="http://鸵鸟工作室.fun"></a><div title="播放/暂停" class="icon-play"></div><h3 class="subtitle">Shader Cheat Sheet</h3><div class="social"><div><div class="share"><a title="获取二维码" class="icon-scan" href="javascript:;"></a></div><div id="qr"></div></div></div><div class="scrollbar"></div></div><div class="section"><div class="article"><div class="main"><h1 class="title">Shader Cheat Sheet</h1><div class="stuff"><span>十月 31, 2018</span><ul class="post-tags-list"><li class="post-tags-list-item"><a class="post-tags-list-link" href="/tags/CheatSheet/">CheatSheet</a></li><li class="post-tags-list-item"><a class="post-tags-list-link" href="/tags/Shader/">Shader</a></li></ul></div><div class="content markdown"><h2 id="CG-函数速查手册"><a href="#CG-函数速查手册" class="headerlink" title="CG 函数速查手册"></a>CG 函数速查手册</h2><p><a href="http://developer.download.nvidia.com/CgTutorial/cg_tutorial_appendix_e.html" target="_blank" rel="noopener">Link</a></p><h2 id="UNITY-MATRIX-MVP"><a href="#UNITY-MATRIX-MVP" class="headerlink" title="UNITY_MATRIX_MVP"></a>UNITY_MATRIX_MVP</h2><p><img src="/media/15409688699223.png" alt=""></p><p><img src="/media/15409688808409.png" alt=""></p><p>使用方法:</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">mul</span><span class="params">(UNITY_MATRIX_MVP,*)</span></span> <span class="comment">//旧版</span></span><br><span class="line"><span class="function"><span class="title">UnityObjectToClipPos</span><span class="params">(*)</span></span> <span class="comment">//新版</span></span><br></pre></td></tr></table></figure><p>作用:</p><p>将模型空间下的 顶点/方向矢量 变换到 剪裁空间</p><p>空间:</p><ul><li>模型空间: 模型内部的坐标系</li><li>世界空间: 世界坐标系 (变换使用 <code>_Object2World(*)</code> )</li><li>观察空间: 以相机为原点的世界空间 (范围没有缩减,只是世界空间的旋转/缩放/平移)</li><li>剪裁空间: 两个剪裁平面(近剪裁面/远剪裁面) 构成的菱形(透视)或方形(正交). 原点可以认为是该区域中的某一点(近剪裁面的中心点). 其内部坐标满足与 -w &lt;= xyz &lt;= w, 不满足条件的顶点均不在剪裁空间内</li><li>屏幕空间: 最终的2D平面</li></ul><h2 id="Properties-种类"><a href="#Properties-种类" class="headerlink" title="Properties 种类"></a>Properties 种类</h2><p><img src="/media/15564429153233.jpg" alt=""></p><p><img src="/media/15564429298123.jpg" alt=""></p><h2 id="Cg-HLSL-variable-types"><a href="#Cg-HLSL-variable-types" class="headerlink" title="Cg/HLSL variable types"></a>Cg/HLSL variable types</h2><ul><li>Color and Vector properties map to <strong>float4</strong>, <strong>half4</strong> or <strong>fixed4</strong> variables.</li><li>Range and Float properties map to <strong>float</strong>, <strong>half</strong> or <strong>fixed</strong> variables.</li><li>Texture properties map to <strong>sampler2D</strong> variables for regular (2D) textures; Cubemaps<br>map to <strong>samplerCUBE</strong>; and 3D textures map to <strong>sampler3D</strong>.</li></ul><p><strong>Cg/HLSL can also accept uniform keyword, but it is not necessary</strong></p><ul><li>The data types for floating-point 2×2, 3×3, and 4×4 matrices are: <strong>float2x2</strong>, <strong>float3x3</strong>, and <strong>float4x4</strong></li><li>Apart from float data types, there are additional half types (<strong>half</strong>, <strong>half2</strong>, <strong>half3</strong>, <strong>half4</strong>, <strong>half2x2</strong>, <strong>half3x3</strong>, <strong>half4x4</strong>, etc.), and fixed types (<strong>fixed</strong>, <strong>fixed2</strong>, <strong>fixed3</strong>, <strong>fixed4</strong>, etc.)</li></ul><p><a href="!https://docs.unity3d.com/Manual/SL-DataTypesAndPrecision.html">Link</a></p><p><a href="https://en.wikibooks.org/wiki/Cg_Programming/Vector_and_Matrix_Operations" target="_blank" rel="noopener">Link2</a></p><blockquote><p>Basic data types<br>The majority of calculations in shaders<br>are carried out on floating-point numbers (which would be float in regular programming languages like C#). Several variants of floating point types are present: float, half and fixed (as well as vector/matrix variants of them, such as half3 and float4x4). These types differ in precision (and, consequently, performance or power usage):</p></blockquote><p><strong>High precision: float</strong></p><blockquote><p>Highest precision floating point value; generally 32 bits (just like float from regular programming languages).</p></blockquote><blockquote><p>Full float precision is generally used for world space positions, texture coordinates, or scalar computations involving complex functions such as trigonometry or power/exponentiation.</p></blockquote><p><strong>Medium precision: half</strong></p><blockquote><p>Medium precision floating point value; generally 16 bits (range of –60000 to +60000, with about 3 decimal digits of precision).</p></blockquote><blockquote><p>Half precision is useful for short vectors, directions, object space positions, high dynamic range colors.</p></blockquote><p><strong>Low precision: fixed</strong></p><blockquote><p>Lowest precision fixed point value. Generally 11 bits, with a range of –2.0 to +2.0 and 1/256th precision.</p></blockquote><blockquote><p>Fixed precision is useful for regular colors (as typically stored in regular textures) and performing simple operations on them.</p></blockquote><p><strong>Integer data types</strong></p><blockquote><p>Integers (int data type) are often used as loop counters or array indices. For this purpose, they generally work fine across various platforms.</p></blockquote><blockquote><p>Depending on the platform, integer types might not be supported by the GPU. For example, Direct3D 9 and OpenGL ES 2.0 GPUs only operate on floating point data, and simple-looking integer expressions (involving bit or logical operations) might be emulated using fairly complicated floating point math instructions.</p></blockquote><blockquote><p>Direct3D 11, OpenGL ES 3, Metal and other modern platforms have proper support for integer data types, so using bit shifts and bit masking works as expected.</p></blockquote><h2 id="NoScaleOffset-标签"><a href="#NoScaleOffset-标签" class="headerlink" title="[NoScaleOffset] 标签"></a>[NoScaleOffset] 标签</h2><p>Properties的纹理加入该标签后则不可以缩放和平移</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Properties</span> &#123;</span><br><span class="line">		_MainTex ("Splat Map", 2D) = "white" &#123;&#125;</span><br><span class="line">		[NoScaleOffset] _Texture1 (<span class="string">"Texture 1"</span>, <span class="number">2</span><span class="keyword">D</span>) = <span class="string">"white"</span> &#123;&#125;</span><br><span class="line">		[NoScaleOffset] _Texture2 (<span class="string">"Texture 2"</span>, <span class="number">2</span><span class="keyword">D</span>) = <span class="string">"white"</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="a2v-v2f"><a href="#a2v-v2f" class="headerlink" title="a2v v2f"></a>a2v v2f</h2><ul><li>a: Application 应用层</li><li>v: Vertex Shader 顶点着色起</li><li>f: Fragment Shader 片元着色起</li></ul><h2 id="MainTex-ST"><a href="#MainTex-ST" class="headerlink" title="_MainTex_ST"></a>_MainTex_ST</h2><p>使用纹理名称后面加<code>_ST</code> 访问纹理的Scale(S),和Translation(T)属性</p><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">float4 <span class="variable">_MainTex_ST</span>; <span class="comment">//声明部分</span></span><br><span class="line"></span><br><span class="line">v2f vert(a2v v) &#123;</span><br><span class="line">    ...</span><br><span class="line">    o.uv = v.texcoord.xy * <span class="variable">_MainTex_ST</span>.xy+ <span class="variable">_MainTex_ST</span>.zw; <span class="comment">//xy是Scale,zw是平移</span></span><br><span class="line">	 	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="tex2D"><a href="#tex2D" class="headerlink" title="tex2D"></a>tex2D</h2><p>用于纹理采样</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fixed4 frag(v2f i) : <span class="type">SV_Target</span> &#123;</span><br><span class="line">  fixed4 <span class="built_in">c</span> = tex2D(_MainTex, i.uv); <span class="comment">//首参数未纹理,第二参数为uv坐标</span></span><br><span class="line">  <span class="keyword">return</span> fixed4(<span class="built_in">c</span>.rgb, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="手动取MipMappingLevel"><a href="#手动取MipMappingLevel" class="headerlink" title="手动取MipMappingLevel"></a>手动取MipMappingLevel</h2><p><a href="https://www.dfworkshop.net/improved-terrain-tiling/" target="_blank" rel="noopener">Link</a></p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// Manually set mip level and return fragment</span></span><br><span class="line"><span class="type">float</span> mipLevel = GetMipLevel(i.texcoord0, _AtlasSize);</span><br><span class="line"><span class="keyword">return</span> tex2Dlod(_MainTex, float4(uv.xy, <span class="number">0</span>, mipLevel));</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> GetMipLevel(float2 iUV, float2 iTextureSize)</span><br><span class="line">&#123;</span><br><span class="line">	float2 dx = ddx(iUV * iTextureSize.x);</span><br><span class="line">	float2 dy = ddy(iUV * iTextureSize.y);</span><br><span class="line">	<span class="type">float</span> d = <span class="built_in">max</span>(<span class="built_in">dot</span>(dx, dx), <span class="built_in">dot</span>(dy,dy));</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0.5</span> * <span class="built_in">log2</span>(d);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://www.opengl.org/discussion_boards/showthread.php/171485-Texture-LOD-calculation-%28useful-for-atlasing%29" target="_blank" rel="noopener">Link</a></p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#define SUB_TEXTURE_SIZE 512.0</span></span><br><span class="line"><span class="meta">#define SUB_TEXTURE_MIPCOUNT 10</span></span><br><span class="line"> </span><br><span class="line"><span class="type">float</span> MipLevel( float2 uv )</span><br><span class="line">&#123;</span><br><span class="line">  float2 dx = ddx( uv * SUB_TEXTURE_SIZE );</span><br><span class="line">  float2 dy = ddy( uv * SUB_TEXTURE_SIZE );</span><br><span class="line">  <span class="type">float</span> d = <span class="built_in">max</span>( <span class="built_in">dot</span>( dx, dx ), <span class="built_in">dot</span>( dy, dy ) );</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// Clamp the value to the max mip level counts</span></span><br><span class="line">  <span class="keyword">const</span> <span class="type">float</span> rangeClamp = <span class="built_in">pow</span>(<span class="number">2</span>, (SUB_TEXTURE_MIPCOUNT - <span class="number">1</span>) * <span class="number">2</span>);</span><br><span class="line">  d = <span class="built_in">clamp</span>(d, <span class="number">1.0</span>, rangeClamp);</span><br><span class="line"> </span><br><span class="line">  <span class="type">float</span> mipLevel = <span class="number">0.5</span> * <span class="built_in">log2</span>(d);</span><br><span class="line">  mipLevel = <span class="built_in">floor</span>(mipLevel);   </span><br><span class="line"> </span><br><span class="line">  <span class="keyword">return</span> mipLevel;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Calculating half texel offset for selected mip level also<br></p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#define SUB_TEXTURE_SIZE 512.0</span></span><br><span class="line"><span class="meta">#define SUB_TEXTURE_MIPCOUNT 10</span></span><br><span class="line"> </span><br><span class="line"><span class="type">float</span> MipLevel( float2 uv, <span class="keyword">out</span> <span class="type">float</span> a_halfOffset )</span><br><span class="line">&#123;</span><br><span class="line">  float2 dx = ddx( uv * SUB_TEXTURE_SIZE );</span><br><span class="line">  float2 dy = ddy( uv * SUB_TEXTURE_SIZE );</span><br><span class="line">  <span class="type">float</span> d = <span class="built_in">max</span>( <span class="built_in">dot</span>( dx, dx ), <span class="built_in">dot</span>( dy, dy ) );</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// Clamp the value to the max mip level counts</span></span><br><span class="line">  <span class="keyword">const</span> <span class="type">float</span> rangeClamp = <span class="built_in">pow</span>(<span class="number">2</span>, SUB_TEXTURE_MIPCOUNT - <span class="number">1</span>);</span><br><span class="line">  d = <span class="built_in">clamp</span>(<span class="built_in">sqrt</span>(d), <span class="number">1.0</span>, rangeClamp);</span><br><span class="line"> </span><br><span class="line">  <span class="type">float</span> mipLevel = <span class="built_in">log2</span>(d);</span><br><span class="line">  mipLevel = <span class="built_in">floor</span>(mipLevel);   </span><br><span class="line"> </span><br><span class="line">  a_halfOffset = d * (<span class="number">1.0</span> / <span class="built_in">pow</span>(<span class="number">2.0</span>, SUB_TEXTURE_MIPCOUNT));</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">return</span> mipLevel;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="标准光照模型"><a href="#标准光照模型" class="headerlink" title="标准光照模型"></a>标准光照模型</h2><blockquote><p>最终点颜色 = 自发光结果(emissive) + 高光反射结果(specular) + 漫反射(diffuse) + 环境光(ambient)</p></blockquote><h3 id="环境光-ambient"><a href="#环境光-ambient" class="headerlink" title="环境光(ambient)"></a>环境光(ambient)</h3><p><img src="/media/15424543652611.jpg" alt=""></p><p><img src="/media/15424543980776.jpg" alt=""></p><p>通过 <code>UNITY_LIGHTMODEL_AMBIENT.xyz</code>访问</p><h3 id="漫反射-diffuse"><a href="#漫反射-diffuse" class="headerlink" title="漫反射(diffuse)"></a>漫反射(diffuse)</h3><blockquote><p>C_diffuse = (C_light <em>M_diffuse) </em>Max(0,n*l)</p></blockquote><p>比如:</p><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fixed3 albedo = tex2D(<span class="variable">_MainTex</span>,i.uv).rgb * <span class="variable">_Color</span>.rgb</span><br><span class="line">fixed3 diffuse <span class="variable">_LightColor0</span>.rgb * albedo * <span class="built_in">max</span>(<span class="number">0</span>,dot(tangentNormal,tangentLightDir))</span><br></pre></td></tr></table></figure><ul><li>C_light : 就是当前点的光源颜色</li><li>M_diffuse : 材质的漫反射系数 也就是当前纹理的采样rgb值 * 叠加的颜色值</li><li>n : 当前坐标系下的单位法线</li><li>l : 当前坐标系下的光线方向</li></ul><p>效果:</p><blockquote><p>根据 光线和法线夹角不同 表现为物体有明暗变化<br>和相机的角度无关,只和光线有关</p></blockquote><p><img src="/media/15424546908225.jpg" alt=""></p><blockquote><p>C_diffuse = (C_light <em>M_diffuse) </em>(A*(n*l)+B)<br>C_diffuse = (C_light <em>M_diffuse) </em>(0.5*(n*l)+0.5)</p></blockquote><p><code>Half Lambert</code> 光照模型. 对漫反射加入偏移修正. 防止背光区域过暗</p><p><img src="/media/15424681736710.jpg" alt=""></p><h3 id="高光反射-Specular"><a href="#高光反射-Specular" class="headerlink" title="高光反射(Specular)"></a>高光反射(Specular)</h3><blockquote><p>C_specular = (C_light <em>M_specular) </em>Max(0,v*r)^M_Gloss</p></blockquote><p>比如</p><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fixed3 viewDir = normalize(<span class="variable">_WorldSpaceCameraPos</span>.xyz-mul(<span class="variable">_Ojbect2World</span>,v.vertext).xyz);</span><br><span class="line">flxed3 specular = <span class="variable">_LightColor</span>.rgb * <span class="variable">_Specular</span>.rgb * pow(setuarte(dot(reflectDir,viewDir)),<span class="variable">_Gloss</span>)</span><br></pre></td></tr></table></figure><ul><li>viewDir : 视角方向,对应公式中的v 是用相机pos-当前Vertext在世界坐标系的Pos得到</li><li>reflectDir : 反射角度,对应公式中的r.使用函数<code>reflect(i,n)</code>求得. 手动求反射角度<a href="https://www.cnblogs.com/graphics/archive/2013/02/21/2920627.html" target="_blank" rel="noopener"><strong>公式及求解方法</strong></a></li></ul><p><code>Blinn-Phone</code>模型</p><blockquote><p>C_specular = (C_light <em>M_specular) </em>Max(0,n*h)^M_Gloss</p></blockquote><ul><li>n : 法线</li><li>h : normalize(入射Dir+光照Dir)</li></ul><p><img src="/media/15424703536517.png" alt=""></p><p>效果:</p><blockquote><p>高光反射用来处理因为光线而产生的亮斑<br>高光反射不对纹理进行采样.所以只是往原有颜色上叠加亮斑(_LightColor.rgb * _Specular.rgb 这两个控制叠加的颜色)<br>_Gloss控制光泽度.也就是值越大则光斑越大</p></blockquote><h2 id="设置全局参数"><a href="#设置全局参数" class="headerlink" title="设置全局参数"></a>设置全局参数</h2><p>比如战争迷雾,所有的Shader都需要访问的参数</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Shader.SetGlobalTexture(<span class="string">"$name"</span>,$<span class="keyword">Property</span><span class="title"></span>)</span><br><span class="line">Shader.SetGlobalFloat(<span class="string">"$name"</span>,$<span class="keyword">Property</span><span class="title"></span>);</span><br><span class="line">Shader.SetGlobalVector(<span class="string">"$name"</span>, new Vector4($<span class="keyword">Property</span><span class="title"></span>, $<span class="keyword">Property</span><span class="title"></span>, $<span class="keyword">Property</span><span class="title"></span>, $<span class="keyword">Property</span><span class="title"></span>));</span><br><span class="line">Shader.SetGlobalColor(<span class="string">"$name"</span>,$<span class="keyword">Property</span><span class="title"></span>);</span><br></pre></td></tr></table></figure><h2 id="查询Shader"><a href="#查询Shader" class="headerlink" title="查询Shader"></a>查询Shader</h2><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tempShader = Shader.<span class="builtin-name">Find</span>(<span class="string">"<span class="variable">$Path</span>"</span>);</span><br></pre></td></tr></table></figure><!--[if lt IE 9]><script>document.createElement('audio');</script><![endif]--><audio id="audio" loop preload="auto" controls data-autoplay="false"><source type="audio/mpeg" src=""></audio><ul id="audio-list" style="display:none"><li title="0" data-url="http://link.hhtjim.com/163/5146554.mp3"></li><li title="1" data-url="http://link.hhtjim.com/qq/001faIUs4M2zna.mp3"></li></ul></div><div id="gitalk-container" class="comment link" data-ae="false" data-ci="" data-cs="" data-r="" data-o="" data-a="" data-d="false">查看评论</div></div></div></div></div></body><script src="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script><script src="//lib.baomitu.com/jquery/1.8.3/jquery.min.js"></script><script src="/js/plugin.js"></script><script src="/js/diaspora.js"></script><link rel="stylesheet" href="/photoswipe/photoswipe.css"><link rel="stylesheet" href="/photoswipe/default-skin/default-skin.css"><script src="/photoswipe/photoswipe.min.js"></script><script src="/photoswipe/photoswipe-ui-default.min.js"></script><div class="pswp" tabindex="-1" role="dialog" aria-hidden="true"><div class="pswp__bg"></div><div class="pswp__scroll-wrap"><div class="pswp__container"><div class="pswp__item"></div><div class="pswp__item"></div><div class="pswp__item"></div></div><div class="pswp__ui pswp__ui--hidden"><div class="pswp__top-bar"><div class="pswp__counter"></div><button class="pswp__button pswp__button--close" title="Close (Esc)"></button> <button class="pswp__button pswp__button--share" title="Share"></button> <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button> <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button><div class="pswp__preloader"><div class="pswp__preloader__icn"><div class="pswp__preloader__cut"><div class="pswp__preloader__donut"></div></div></div></div></div><div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap"><div class="pswp__share-tooltip"></div></div><button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)"></button> <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)"></button><div class="pswp__caption"><div class="pswp__caption__center"></div></div></div></div></div><!-- rebuild by neat -->